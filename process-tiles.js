import sharp from "sharp";
import fs from "fs/promises";
import path from "path";

const RAW_DIR = "public/tiles/raw";
const OUTPUT_DIR = "public/tiles";
const CONFIG_FILE = "src/map-config-generated.js";
const QUADS = ["tl", "tr", "bl", "br"];

const CONSTANTS = {
  MIN_LON: 87.18758755927735,
  MAX_LON: 88.24209927802731,
  MIN_LAT: 26.431307064519423,
  MAX_LAT: 26.902398802791005,
};

async function findTimeStringsFromOutput() {
  const files = await fs.readdir(OUTPUT_DIR);
  const timeSet = new Set();
  const tileFileRegex = /^tile_backup_(.+?)_(tl|tr|bl|br)\.png$/;

  for (const file of files) {
    const match = file.match(tileFileRegex);
    if (match) {
      timeSet.add(match[1]);
    }
  }

  return Array.from(timeSet).sort();
}

async function generateCoordinateConfig(timeStrings) {
  const { MIN_LON, MAX_LON, MIN_LAT, MAX_LAT } = CONSTANTS; // Find the center points

  const MID_LON = (MIN_LON + MAX_LON) / 2;
  const MID_LAT =
    (MIN_LAT + MAX_LAT) / 2; /* MapLibre requires coordinates in the order: 
¬† ¬† [top-left, top-right, bottom-right, bottom-left] 
¬† ¬† */

  const QUADRANT_COORDS = {
    tl: [
      [MIN_LON, MAX_LAT],
      [MID_LON, MAX_LAT],
      [MID_LON, MID_LAT],
      [MIN_LON, MID_LAT],
    ],
    tr: [
      [MID_LON, MAX_LAT],
      [MAX_LON, MAX_LAT],
      [MAX_LON, MID_LAT],
      [MID_LON, MID_LAT],
    ],
    bl: [
      [MIN_LON, MID_LAT],
      [MID_LON, MID_LAT],
      [MID_LON, MIN_LAT],
      [MIN_LON, MIN_LAT],
    ],
    br: [
      [MID_LON, MID_LAT],
      [MAX_LON, MID_LAT],
      [MAX_LON, MIN_LAT],
      [MID_LON, MIN_LAT],
    ],
  };

  let jsContent = `// This file is auto-generated by process-tiles.js. DO NOT EDIT MANUALLY.\n\n`;
  jsContent += `export const QUADS = ${JSON.stringify(QUADS)};\n`;
  jsContent += `export const QUADRANT_COORDS = ${JSON.stringify(
    QUADRANT_COORDS
  )};\n`;
  jsContent += `export const MIN_LON = ${MIN_LON};\n`;
  jsContent += `export const MAX_LON = ${MAX_LON};\n`;
  jsContent += `export const MIN_LAT = ${MIN_LAT};\n`;
  jsContent += `export const MAX_LAT = ${MAX_LAT};\n`;
  jsContent += `export const TIME_STRINGS = ${JSON.stringify(timeStrings)};\n`;

  return jsContent;
}

async function splitImage(fileName) {
  const SLUG = path.parse(fileName).name.replace("tile_backup_", "");
  const SOURCE_PATH = path.join(RAW_DIR, fileName);

  console.log(`Processing: ${fileName}`);

  let image;
  try {
    image = sharp(SOURCE_PATH);
  } catch (e) {
    console.error(` ‚úó Error loading image: ${SOURCE_PATH}. Skipping.`);
    return;
  }

  const metadata = await image.metadata();
  const width = metadata.width;
  const height = metadata.height;

  if (!width || !height) {
    console.error(" ‚úó Could not read image dimensions. Skipping.");
    return;
  }

  const halfWidth = Math.floor(width / 2);
  const halfHeight = Math.floor(height / 2);

  const cropJobs = [
    { suffix: "tl", left: 0, top: 0, width: halfWidth, height: halfHeight },
    {
      suffix: "tr",
      left: halfWidth,
      top: 0,
      width: width - halfWidth,
      height: halfHeight,
    },
    {
      suffix: "bl",
      left: 0,
      top: halfHeight,
      width: halfWidth,
      height: height - halfHeight,
    },
    {
      suffix: "br",
      left: halfWidth,
      top: halfHeight,
      width: width - halfWidth,
      height: height - halfHeight,
    },
  ];

  const promises = cropJobs.map((job) => {
    const outputName = `tile_backup_${SLUG}_${job.suffix}.png`;
    const outputPath = path.join(OUTPUT_DIR, outputName);

    return image
      .clone()
      .extract({
        left: job.left,
        top: job.top,
        width: job.width,
        height: job.height,
      })
      .toFile(outputPath)
      .then(() => console.log(` ‚úì Created ${outputName}`))
      .catch((err) => console.error(` ‚úó Error creating ${outputName}: ${err}`));
  });

  await Promise.all(promises);

  console.log(`Finished processing ${fileName}.`);
  try {
    await fs.unlink(SOURCE_PATH);
    console.log(` üóëÔ∏è Original file ${fileName} deleted from raw directory.`);
  } catch (err) {
    console.error(` ‚úó Could not delete original file: ${err}`);
  }
}

async function processRawDirectory() {
  try {
    await fs.mkdir(RAW_DIR, { recursive: true });
    await fs.mkdir(OUTPUT_DIR, { recursive: true });

    const files = await fs.readdir(RAW_DIR);
    const imageFiles = files.filter(
      (f) => f.startsWith("tile_backup_") && f.endsWith(".png")
    );

    if (imageFiles.length === 0) {
      console.log(
        `No 'tile_backup_*.png' files found in ${RAW_DIR}. Skipping image processing.`
      );
    } else {
      console.log(`Found ${imageFiles.length} images to process.`);
      for (const file of imageFiles) {
        await splitImage(file);
      }
    }

    console.log("\nSearching for all processed tile slugs...");
    const allTimeStrings = await findTimeStringsFromOutput();

    if (allTimeStrings.length === 0) {
      console.warn(
        "‚ö†Ô∏è WARNING: No processed tiles found in the output directory. TIME_STRINGS will be empty."
      );
    } else {
      console.log(`Found ${allTimeStrings.length} unique time steps.`);
    }

    console.log("\nGenerating coordinate configuration file...");
    const configContent = await generateCoordinateConfig(allTimeStrings);
    await fs.writeFile(CONFIG_FILE, configContent);
    console.log(`‚úÖ Successfully wrote config to ${CONFIG_FILE}`);

    console.log("\n‚úÖ ALL TASKS COMPLETE.");
  } catch (err) {
    console.error("\nAn unexpected error occurred during processing:", err);
  }
}

processRawDirectory();
